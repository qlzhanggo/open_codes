/**
 *  @file diff_type.h
 *
 *  Created on: Aug 19, 2017
 *    Author: zehuag
 */

#ifndef DIFF_TYPE_HPP_
#define DIFF_TYPE_HPP_

#include <petsc.h>
#include <petscsys.h>

#define cubic(x) (x*x*x)
typedef enum {CDF, FOU, QUICK, SMART, MINMOD, VONOS, WACEB} UWtype;
//the order is 0, 1, 2, 3...

/*
 * define the method to construct the flux
 */

class flux_op
{
public:
	flux_op() {};

	// upwind scheme: from upstream to downstream Ur, Uu, Ud with uniform mesh
	double operator() (const PetscScalar &Ur, const PetscScalar &Uu, const PetscScalar &Ud, const UWtype type)
	{
		double fnorm;

		switch (type) {
		case WACEB :
			if (Ur != Ud)
				fnorm = (Uu - Ur) / (Ud - Ur);
			else
				fnorm = -1.0;
			if (fnorm < 0.0 || fnorm > 1.0)
				return Uu;
			else if (fnorm>=0.0 && fnorm < 0.3)
				return 2*Uu - Ur;
			else if (fnorm >= 0.3 && fnorm < 5.0/6.0)
				return (3.0/8.0)*Ud + (6.0/8.0)*Uu - 1.0/8.0*Ur;
			else if (fnorm >= 5.0/6.0 && fnorm <= 1.0)
				return Ud;

			break;

		case VONOS :
			if (Ur != Ud)
				fnorm = (Uu - Ur) / (Ud - Ur);
			else
				fnorm = -1.0;

			if (fnorm < 0.0 || fnorm > 1.0)
				return Uu;
			else if (fnorm>=0.0 && fnorm < 3.0/74.0)
				return 10*Uu - 9.0*Ur;
			else if (fnorm >= 3.0/74.0 && fnorm < 0.5)
				return (3.0/8.0)*Ud + (6.0/8.0)*Uu - 1.0/8.0*Ur;
			else if (fnorm >= 0.5 && fnorm <= 2.0/3.0)
				return 1.5*Uu - 0.5*Ur;
			else if (fnorm >= 2.0/3.0 && fnorm <= 1.0)
				return Ud;

			break;

		case QUICK :
			return (3.0/8.0)*Ud + (6.0/8.0)*Uu - 1.0/8.0*Ur;
			break;

		case FOU :
			return Uu;
			break;

		case CDF :
			return 0.5*(Uu + Ud);
			break;

		default :
			return Uu;
			break;
		}
	}

  // upwind scheme: from upstream to downstream Ur, Uu, Ud with non-uniform mesh (cell-centered)
  double operator() (const PetscScalar &Ur, const PetscScalar &Uu, const PetscScalar &Ud, const double&xr, const double&xu, const double&xd, const double &x, const UWtype type) 
  {
    double r1, r2, q1, q2, dd;
    double fnorm;
	
    //PetscPrintf(PETSC_COMM_WORLD,"%i, %i, %i\n",CDF, FOU, QUICK);

    switch (type) {

    case WACEB :
	PetscPrintf(PETSC_COMM_WORLD,"not supported yet!\n");
        abort();
     break;

    case VONOS:
	PetscPrintf(PETSC_COMM_WORLD,"not supported yet!\n");
        abort();
     break;

    case SMART:
	PetscPrintf(PETSC_COMM_WORLD,"not supported yet!\n");
        abort();
     break;

    //quick flux
    case QUICK:
      return (x - xu) / (xd - xu) * (x - xr) / (xd - xr) * Ud + 
             (x - xd) / (xu - xd) * (x - xr) / (xu - xr) * Uu + 
             (x - xu) / (xr - xu) * (x - xd) / (xr - xd) * Ur;
      break;

    //central flux
    case CDF :
      return 0.5*(Uu + Ud);
      break;
          
    //first order upwind
    case FOU:
      return Uu;
      break;

    default :
      return Uu;
      break;
    }
  }



  /* dfdx a simple way to compute the derivative on the face
   * @f1, @f2, @f3 are the values near the face
   * @dx1, @dx2, @dx3 are the distances of the given values away from the face
   */
  double dfdx(const double &f1, const double &f2, const double &f3, const double &dx1, const double &dx2, const double &dx3)
  {
  	double a[3], b[3], c[3];
  	a[0] = dx1; a[1] = dx2; a[2] = dx3;
  	b[0] = 0.5*dx1*dx1; b[1] = 0.5*dx2*dx2; b[2] = 0.5*dx3*dx3;
  	c[0] = f1; c[1] = f2; c[2] = f3;
  
  	return (b[0]*c[1]+b[1]*c[2]+b[2]*c[0] - c[0]*b[1]-c[1]*b[2]-c[2]*b[0])
  			/ (b[0]*a[1]+b[1]*a[2]+b[2]*a[0] - a[0]*b[1]-a[1]*b[2]-a[2]*b[0]) ;
  }


  /* dfdx: a high-order accurate version of dfdx
   * The code is automatically generated by maple by (so do not debug here):
   *    fint2 := (x-x2)*(x-x3)*(x-x4)*f1/((x1-x2)*(x1-x3)*(x1-x4))+(x-x1)*(x-x3)*(x-x4)*f2/((x2-x1)*(x2-x3)*(x2-x4))+(x-x1)*(x-x2)*(x-x4)*f3/((x3-x1)*(x3-x2)*(x3-x4))+(x-x1)*(x-x2)*(x-x3)*f4/((x4-x1)*(x4-x2)*(x4-x3))
   *    dfdx2 := simplify(subs(x3 = x+d3, x2 = x+d2, x1 = x+d1, x4 = x+d4, diff(fint2, x)))
   *    with(CodeGeneration): C(dfdx2)
   */
  double dfdx(const double &f1, const double &f2, const double &f3, const double &f4, 
              const double &d1, const double &d2, const double &d3, const double &d4)
  {
  	return (((f3 - f4) * d2 * d2 + (-f2 + f4) * d3 * d3 + d4 * d4 * (f2 - f3)) * cubic(d1) + ((-f3 + f4) * cubic(d2) + (f2 - f4) * cubic(d3) - cubic(d4) * (f2 - f3)) * d1 * d1 + ((f1 - f4) * d3 * d3 - d4 * d4 * (f1 - f3)) * cubic(d2) + ((-f1 + f4) * cubic(d3) + cubic(d4) * (f1 - f3)) * d2 * d2 + d3 * d3 * d4 * d4 * (f1 - f2) * (d3 - d4)) / (d1 - d2) / (d1 - d3) / (d1 - d4) / (d2 - d3) / (d2 - d4) / (d3 - d4);
  }



	~flux_op() {};

};

#endif /* DIFF_TYPE_HPP_ */
